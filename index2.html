<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ツリー罫線エディタ（簡易版・root表示＆削除対応・IndexedDB+入出力）</title>
<style>
  :root{--bg:#0b1020;--card:#111934;--ink:#e9edff;--mut:#98a3cb;--acc:#6aa6ff;--line:#2a3768;--sel:#1a2550;--pop:#0f1635;}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#091025,#0b1430);color:var(--ink);font:14px/1.6 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  header{position:sticky;top:0;z-index:2;background:#0d1530;border-bottom:1px solid #1d2b59;padding:10px 12px;display:flex;gap:8px;align-items:center}
  header h1{margin:0;font-size:14px;font-weight:700;opacity:.95}
  header .sp{flex:1}
  header button{border:1px solid #2a3b70;background:#18234a;color:var(--ink);border-radius:8px;padding:6px 10px;cursor:pointer}
  header button:hover{border-color:#3c54a3}
  main{max-width:980px;margin:0 auto;padding:16px}
  .card{background:var(--card);border:1px solid #1d2b59;border-radius:12px;overflow:hidden}
  .tree{padding:10px 12px}
  .line{display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:6px;white-space:pre}
  .line:hover{background:#121d43}
  .line.active{background:var(--sel);outline:1px solid #2c3c78}
  .line.root{background:#0e1942;border:1px dashed #2b3c7a}
  .title{flex:1}
  .badge{display:inline-block;padding:2px 8px;border:1px solid #2a3b70;border-radius:999px;color:#c7d2ff;background:#0f1635;font-size:12px;margin-right:6px}
  .mut{color:var(--mut)}
  .popover{margin:6px 0 8px 28px;background:var(--pop);border:1px solid #27346a;border-radius:10px;padding:8px;display:flex;flex-wrap:wrap;gap:8px}
  .popover button{border:1px solid #2a3b70;background:#18234a;color:var(--ink);border-radius:8px;padding:6px 10px;cursor:pointer}
  .popover button:hover{border-color:#3c54a3}
  .rename{display:flex;gap:6px;align-items:center}
  .rename input{background:#0f1738;border:1px solid #223162;border-radius:8px;color:var(--ink);padding:6px 8px;min-width:240px}
  .danger{border-color:#5a1c2c !important;background:#2a0e17 !important;color:#ffd9e1 !important}
  .empty{color:var(--mut);padding:14px}
  footer{padding:10px 12px;border-top:1px solid #1d2b59;background:#0f1738;font-size:12px;color:#mut}
</style>
</head>
<body>
  <header>
    <h1>ツリー罫線エディタ（簡易版）</h1>
    <span class="sp"></span>
    <button id="addRoot">最上位を追加</button>
    <button id="exportCSV">CSV（罫線）DL</button>
    <button id="importCSV">CSV 読込</button>
    <button id="reset">リセット</button>
  </header>
  <main>
    <div class="card">
      <div id="tree" class="tree"></div>
      <footer>
        クリックで編集メニューを表示：子を作成 / 名前を編集 / 上下に移動 / 削除（rootは削除不可）。保存は <strong>IndexedDB</strong> に自動保存。
      </footer>
    </div>
  </main>

<script>
// ---------------- IndexedDB ----------------
const DB_NAME = 'simple-outline-editor-db';
const STORE = 'tree';
let db = null;

function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e)=>{
      db = e.target.result;
      if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = (e)=>{ db = e.target.result; resolve(); };
    req.onerror = (e)=> reject(e);
  });
}
function idbSet(key, val){
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    tx.objectStore(STORE).put(val, key);
    tx.oncomplete = ()=> resolve();
    tx.onerror = (e)=> reject(e);
  });
}
function idbGet(key){
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const rq = tx.objectStore(STORE).get(key);
    rq.onsuccess = ()=> resolve(rq.result);
    rq.onerror = (e)=> reject(e);
  });
}

// ---------------- モデル ----------------
const $ = (id)=>document.getElementById(id);
const uid = ()=> Math.random().toString(36).slice(2)+Date.now().toString(36);
const now = ()=> Date.now();

/** @typedef {{id:string,title:string,children:NodeItem[],createdAt:number}} NodeItem */

let root = { id:'root', title:'root', createdAt: now(), children:[] }; // 起動時に load() で置換

async function save(){ await idbSet('root', root); }
async function load(){ return await idbGet('root'); }

// ---------------- レンダリング ----------------
let openEditorFor = null; // 選択中 id

function render(){
  const host = $('tree');
  host.innerHTML = '';
  const lines = buildOutlineLines(root);
  if(!lines.length){
    const empty = document.createElement('div');
    empty.className = 'empty';
    empty.textContent = '（項目はまだありません。右上の「最上位を追加」から作成してください）';
    host.appendChild(empty);
    return;
  }
  lines.forEach(lineInfo=>{
    const row = document.createElement('div');
    row.className = 'line' + (openEditorFor===lineInfo.node.id? ' active':'') + (lineInfo.isRoot? ' root':'');
    row.dataset.id = lineInfo.node.id;

    if(lineInfo.isRoot){
      const b = document.createElement('span');
      b.className = 'badge';
      b.textContent = 'ROOT';
      row.appendChild(b);
    }

    const prefix = document.createElement('span');
    prefix.className = 'mut';
    prefix.textContent = lineInfo.prefix;

    const title = document.createElement('span');
    title.className = 'title';
    title.textContent = lineInfo.node.title || '(無題)';

    row.appendChild(prefix);
    row.appendChild(title);
    host.appendChild(row);

    row.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(openEditorFor===lineInfo.node.id){ openEditorFor=null; render(); return; }
      openEditorFor = lineInfo.node.id; render();
    });

    if(openEditorFor===lineInfo.node.id){
      host.appendChild(buildPopover(lineInfo.node));
    }
  });
}

function buildOutlineLines(root){
  const out=[];
  // root 行
  out.push({ node: root, prefix: '', isRoot: true });
  const walk=(node, flags)=>{
    node.children.forEach((child, idx)=>{
      const isLast = idx===node.children.length-1;
      out.push({ node: child, prefix: makePrefix([...flags, isLast]), isRoot: false });
      walk(child, [...flags, isLast]);
    });
  };
  walk(root, []);
  return out;
}

function makePrefix(flags){
  if(!flags.length) return '';
  let s='';
  for(let i=0;i<flags.length-1;i++) s += flags[i] ? '    ' : '│   ';
  s += flags[flags.length-1] ? '└─ ' : '├─ ';
  return s;
}

// ---------------- 編集ポップオーバー ----------------
function buildPopover(node){
  const box = document.createElement('div');
  box.className = 'popover';

  // 子を作る
  const btnChild = document.createElement('button');
  btnChild.textContent = '中に項目を作る';
  btnChild.onclick = ()=>{ node.children.push({ id:uid(), title:'新規項目', createdAt:now(), children:[] }); save(); render(); };

  // 名前編集
  const renameWrap = document.createElement('div');
  renameWrap.className = 'rename';
  const nameInput = document.createElement('input');
  nameInput.value = node.title || '';
  const btnStartRename = document.createElement('button'); btnStartRename.textContent='項目名を編集';
  const btnSaveRename = document.createElement('button'); btnSaveRename.textContent='保存'; btnSaveRename.style.display='none';
  const btnCancelRename = document.createElement('button'); btnCancelRename.textContent='キャンセル'; btnCancelRename.style.display='none';
  btnStartRename.onclick=()=>{ nameInput.style.display=''; btnSaveRename.style.display=''; btnCancelRename.style.display=''; btnStartRename.style.display='none'; nameInput.focus(); };
  btnSaveRename.onclick=()=>{ node.title = nameInput.value.trim() || (node.id==='root'?'root':'(無題)'); save(); openEditorFor=null; render(); };
  btnCancelRename.onclick=()=>{ openEditorFor=null; render(); };
  nameInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter') btnSaveRename.click(); if(e.key==='Escape') btnCancelRename.click(); });
  nameInput.style.display='none';
  renameWrap.appendChild(nameInput); renameWrap.appendChild(btnSaveRename); renameWrap.appendChild(btnCancelRename);

  // 上下移動（root不可）
  const btnUp = document.createElement('button'); btnUp.textContent='上へ移動'; btnUp.onclick=()=> moveInSiblings(node,-1);
  const btnDown = document.createElement('button'); btnDown.textContent='下へ移動'; btnDown.onclick=()=> moveInSiblings(node,+1);

  // 削除（root不可）
  const btnDelete = document.createElement('button'); btnDelete.textContent='項目を削除'; btnDelete.className='danger'; btnDelete.onclick=()=> deleteNode(node);

  const btnClose = document.createElement('button'); btnClose.textContent='閉じる'; btnClose.onclick=()=>{ openEditorFor=null; render(); };

  box.appendChild(btnChild);
  box.appendChild(btnStartRename);
  box.appendChild(renameWrap);
  if(node.id!=='root') { box.appendChild(btnUp); box.appendChild(btnDown); box.appendChild(btnDelete); }
  box.appendChild(btnClose);
  return box;
}

function findParentOf(target, cur=root){
  for(const child of cur.children){
    if(child.id===target.id) return cur;
    const p = findParentOf(target, child);
    if(p) return p;
  }
  return null; // root など
}

function moveInSiblings(node, delta){
  const parent = findParentOf(node);
  if(!parent) return; // root
  const idx = parent.children.findIndex(c=>c.id===node.id);
  if(idx<0) return;
  const to = idx + delta;
  if(to<0 || to>=parent.children.length) return;
  const arr = parent.children; [arr[idx], arr[to]] = [arr[to], arr[idx]];
  save(); render();
}

function deleteNode(node){
  if(node.id==='root'){ alert('root は削除できません'); return; }
  const parent = findParentOf(node); if(!parent) return;
  if(!confirm(`「${node.title||'(無題)'}」を削除します。よろしいですか？\n（配下の項目もまとめて削除されます）`)) return;
  const idx = parent.children.findIndex(c=>c.id===node.id);
  if(idx>=0){ parent.children.splice(idx,1); save(); openEditorFor=null; render(); }
}

// ---------------- CSV 出力 ----------------
function toCSV(rows, headers){
  const esc = (s)=>{ s=s==null?'':String(s).replace(/\r?\n/g,'\n'); return /[",\n]/.test(s)? '"'+s.replace(/"/g,'""')+'"' : s; };
  const lines = [headers.map(esc).join(',')];
  rows.forEach(r=> lines.push(headers.map(h=>esc(r[h]??'')).join(',')) );
  return lines.join('\r\n');
}

function buildOutlineRows(){
  const rows=[]; rows.push({ outline:(root.title||'root') });
  const walk=(node, flags)=>{
    node.children.forEach((c,i)=>{
      rows.push({ outline: makePrefix([...flags, i===node.children.length-1]) + (c.title||'(無題)') });
      walk(c, [...flags, i===node.children.length-1]);
    });
  };
  walk(root, []); return rows;
}

function download(filename, text){
  const blob = new Blob([text], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url);
}

$('exportCSV').onclick = ()=>{
  const csv = toCSV(buildOutlineRows(), ['outline']);
  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
  download(`outline-${stamp}.csv`, csv);
};

// ---------------- インポート（JSON/CSV） ----------------
function openFileOnce(accept, onLoad){
  const input = document.createElement('input');
  input.type='file'; input.accept=accept;
  input.onchange = async (e)=>{ const f=e.target.files&&e.target.files[0]; if(!f) return; const text=await f.text(); onLoad(text,f); };
  input.click();
}
/*
// JSON エクスポート
$('exportJSON').onclick = async ()=>{
  const payload = { version:1, exportedAt:new Date().toISOString(), root };
  const text = JSON.stringify(payload, null, 2);
  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
  const blob = new Blob([text], {type:'application/json;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=`outline-${stamp}.json`; a.click(); URL.revokeObjectURL(url);
};

// JSON 読込（replace/merge）
$('importJSON').onclick = ()=>{
  openFileOnce('.json,application/json', async (text)=>{
    try{
      const data = JSON.parse(text);
      const imported = data && data.root && data.root.id ? data.root : (data && data.id ? data : null);
      if(!imported || !Array.isArray(imported.children)) throw new Error('bad json');
      const mode = prompt('インポートモード: replace(全置換)/merge(マージ)','merge');
      if(mode==='replace'){
        if(!confirm('現在のデータを全置換します。よろしいですか？')) return;
        root = imported; root.id='root';
      }else{
        const mergeChildren=(dst,src)=>{
          src.children.forEach(s=>{
            const f = dst.children.find(d=> (d.title||'')===(s.title||''));
            if(f){ mergeChildren(f,s); }
            else dst.children.push({ id:uid(), title:s.title||'', createdAt:s.createdAt||Date.now(), children:(s.children||[]).map(x=>({ id:uid(), title:x.title||'', createdAt:x.createdAt||Date.now(), children:(x.children||[]) }))});
          });
        };
        mergeChildren(root, imported);
      }
      await save(); render(); alert('JSON をインポートしました。');
    }catch(e){ alert('JSON 読み込みに失敗しました'); }
  });
};
*/
// CSV パース
function parseCSV(text){
  const rows=[]; let i=0,cur='',row=[],q=false;
  while(i<text.length){ const ch=text[i];
    if(q){ if(ch==='"'){ if(text[i+1]==='"'){cur+='"'; i+=2; continue;} q=false; i++; continue;} cur+=ch; i++; continue; }
    if(ch==='"'){ q=true; i++; continue; }
    if(ch===','){ row.push(cur); cur=''; i++; continue; }
    if(ch==='\r'){ i++; continue; }
    if(ch==='\n'){ row.push(cur); rows.push(row); cur=''; row=[]; i++; continue; }
    cur+=ch; i++; }
  row.push(cur); rows.push(row); return rows.filter(r=>!(r.length===1&&r[0]===''));
}
function csvRowsToObjects(rows){ if(!rows.length) return []; const header=rows[0]; const idx={}; header.forEach((h,i)=>idx[h.trim()]=i); const out=[]; for(let r=1; r<rows.length; r++){ const arr=rows[r]; const obj={}; header.forEach((h,i)=> obj[h.trim()] = (arr[i]??'').toString()); out.push(obj);} return out; }

function parseOutlineLine(s){
  if(!/├─ |└─ /.test(s)) return { depth:0, title:s.trim() };
  const m = s.match(/^(.*?)(├─ |└─ )(.*)$/);
  if(!m) return { depth:0, title:s.trim() };
  const prefix = m[1]; const title = m[3].trim();
  let depth = 0; for(let i=0;i<prefix.length;){ if(prefix.startsWith('│   ', i) || prefix.startsWith('    ', i)){ depth++; i+=4; } else { i++; } }
  return { depth: depth+1, title };
}

$('importCSV').onclick = ()=>{
  openFileOnce('.csv,text/csv', async (text)=>{
    const rows = csvRowsToObjects(parseCSV(text));
    if(!rows.length || !('outline' in rows[0])){ alert('CSVヘッダに outline 列が必要です'); return; }
    const newRoot = { id:'root', title:'root', createdAt:Date.now(), children:[] };
    const stack = [newRoot];
    rows.forEach(r=>{
      const s = (r.outline||'').toString(); if(!s.trim()) return;
      const { depth, title } = parseOutlineLine(s);
      if(depth===0){ newRoot.title = title || 'root'; return; }
      while(stack.length>depth) stack.pop();
      while(stack.length<depth) stack.push(stack[stack.length-1]);
      const parent = stack[depth-1] || newRoot;
      const node = { id:uid(), title: title||'(無題)', createdAt:Date.now(), children:[] };
      parent.children.push(node);
      stack[depth] = node;
    });
    root = newRoot; await save(); render(); alert('CSV をインポートしました');
  });
};

// ---------------- ルート操作＆起動 ----------------
$('addRoot').onclick = ()=>{ root.children.push({ id:uid(), title:'新規項目', createdAt:now(), children:[] }); save(); render(); };
$('reset').onclick = async ()=>{ if(confirm('ツリーを初期化します。よろしいですか？')){ root = { id:'root', title:'root', createdAt:now(), children:[] }; await save(); openEditorFor=null; render(); } };

(async()=>{ await openDB(); const loaded = await load(); if(loaded && loaded.id){ root = loaded; } render(); })();
</script>
</body>
</html>
